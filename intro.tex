\section{Introduction}
Most deep learning and image processing programs rely heavily on loops, which represent the vast majority of a program's total execution time. Due to the high number of loops in each loop nest, it is possible to schedule the loops in many different, yet functionally equivalent ways. Choosing a bad program schedule can result in a dramatically worse execution time. Similar schedules can include different optimizations such as inlining, tiling, vectorization, and multithreading, which can significantly impact the performance of the program. The number of possible optimizations grows exponentially with the number of loops in the loop nest. With the end of Moore's law and the booming of new application-specific integrated circuits (ASICs), the scheduling challenge becomes harder as the scheduler also needs to generate different schedules for different target architectures.

Due to its complexity, scheduling is often done using heuristics and tremendous amounts of hand engineering. Big vendors often hire engineers that are dedicated to manually writing schedules for different applications. This incurs huge costs both in terms of time and human capital. Heuristics mostly fall short in achieving optimal performance~\cite{cummins2017synthesizing,haj2020autophase,haj2020neurovectorizer}. Ideally, the scheduler should consider all the possible schedules and the target hardware to find the optimal schedule. Unfortunately,  the space of possible schedules for different hardware targets is prohibitively large to explore. To cope with that, a recent work~\cite{adams2019learning} proposed using beam search with a learned cost model to find good schedules. While this approach achieves promising improvements over the baseline default auto-scheduler in Halide~\cite{ragan2013halide}, it often fails to find the optimal schedule. The main issue lies in the greediness of beam search and the inability of the cost model to accurately predict the performance of partially scheduled (not meaningful) programs, which is needed at every intermediate step of the beam search. This results in a multiplied error at every decision made in the beam search tree and an inability to explore schedules that are less rewarding in the short term but potentially more rewarding in the long term.

To overcome these challenges we propose ProTuner, which uses Monte Carlo Tree Search (MCTS)~\cite{browne2012survey}. In ProTuner, we formulate the scheduling problem as a Markov decision process (MDP) where each intermediate schedule is represented as a state and the actions are the different intermediate optimizations that could be applied next. The reward is proportional to the execution time improvement. The solution would be the actions that lead to the optimal schedule and hence solving the MDP can guarantee the optimal schedule. One promising algorithm to solve MDPs is MCTS. MCTS builds a search tree using selection, expansion, simulation, and backpropagation that explore the search space. After some number of iterations, the tree decides which next step (of intermediate scheduling optimization) to perform next. When this happens, a new root is determined and the MCTS starts again. With the upper confidence bound (UCB)~\cite{auer2002finite} the MCTS is guaranteed to converge to the optimal solution after enough iterations.

MCTS makes decisions by looking ahead, evaluating complete schedules, avoiding greediness, and considering the expected long term reward of scheduling decisions, which also makes it more resilient to noise in the cost model. We, therefore, conjecture that MCTS is a better fit for finding the optimal schedule compared to beam search. To explore that, we implemented ProTuner on top of Halide~\cite{ragan2013halide}, evaluated it, and found that ProTuner with MCTS outperforms beam search or achieves comparable performance on all of the evaluated benchmarks, achieving up to $3.25\times$ better performance. %Our results show that MCTS outperforms beam search by 1.1X-2X on different benchmarks. To further boost our performance we combined real execution time evaluation with the learned cost model allowing us to achieve 3X better performance. 

Our main contributions are:
\begin{itemize}
    \item We propose to formulate the scheduling problem as an MDP and solve it using MCTS with the UCB.
    \item We build ProTuner on top of Halide and explore different MCTS techniques to improve and fine tune its performance.
    \item Rigorous evaluations that show ProTuner achieves up to $3.5\times$ better performance than beam search on a suite of 16 real benchmarks.
    \item We show how ProTuner can combine real execution time evaluation with the learned cost model and show this can further boost the performance.
\end{itemize}